{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\nvar _t = require(\"@babel/types\");\nvar _parser = require(\"@babel/parser\");\nvar _codeFrame = require(\"@babel/code-frame\");\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n  let name;\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}","map":{"version":3,"names":["_t","require","_parser","_codeFrame","isCallExpression","isExpressionStatement","isFunction","isIdentifier","isJSXIdentifier","isNewExpression","isPlaceholder","isStatement","isStringLiteral","removePropertiesDeep","traverse","PATTERN","parseAndBuildMetadata","formatter","code","opts","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","ast","parseWithCodeFrame","parser","validate","syntactic","placeholders","placeholderNames","Set","legacy","isLegacyRef","value","undefined","placeholderVisitorHandler","Object","assign","node","ancestors","state","_state$placeholderWhi","name","Error","test","has","slice","parent","key","length","type","expectedNode","push","resolve","resolveAncestors","isDuplicate","add","i","index","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","parse","err","loc","message","codeFrameColumns","start"],"sources":["/home/nathan/Documents/project/node_modules/@babel/template/src/parse.ts"],"sourcesContent":["import {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { TraversalAncestors, TraversalHandler } from \"@babel/types\";\nimport { parse } from \"@babel/parser\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport type { TemplateOpts, ParserOpts } from \"./options\";\nimport type { Formatter } from \"./formatters\";\n\nexport type Metadata = {\n  ast: t.File;\n  placeholders: Array<Placeholder>;\n  placeholderNames: Set<string>;\n};\n\ntype PlaceholderType = \"string\" | \"param\" | \"statement\" | \"other\";\nexport type Placeholder = {\n  name: string;\n  resolve: (a: t.File) => { parent: t.Node; key: string; index?: number };\n  type: PlaceholderType;\n  isDuplicate: boolean;\n};\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nexport default function parseAndBuildMetadata<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): Metadata {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  } = opts;\n\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n\n  removePropertiesDeep(ast, {\n    preserveComments,\n  });\n\n  formatter.validate(ast);\n\n  const syntactic: MetadataState[\"syntactic\"] = {\n    placeholders: [],\n    placeholderNames: new Set(),\n  };\n  const legacy: MetadataState[\"legacy\"] = {\n    placeholders: [],\n    placeholderNames: new Set(),\n  };\n  const isLegacyRef: MetadataState[\"isLegacyRef\"] = { value: undefined };\n\n  traverse(ast, placeholderVisitorHandler as TraversalHandler<any>, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders,\n  });\n\n  return {\n    ast,\n    ...(isLegacyRef.value ? legacy : syntactic),\n  };\n}\n\nfunction placeholderVisitorHandler(\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: MetadataState,\n) {\n  let name: string;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\n        \"%%foo%%-style placeholders can't be used when \" +\n          \"'.syntacticPlaceholders' is false.\",\n      );\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (\n    !state.isLegacyRef.value &&\n    (state.placeholderPattern != null || state.placeholderWhitelist != null)\n  ) {\n    // This check is also in options.js. We need it there to handle the default\n    // .syntacticPlaceholders behavior.\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  if (\n    state.isLegacyRef.value &&\n    (state.placeholderPattern === false ||\n      !(state.placeholderPattern || PATTERN).test(name)) &&\n    !state.placeholderWhitelist?.has(name)\n  ) {\n    return;\n  }\n\n  // Keep our own copy of the ancestors so we can use it in .resolve().\n  ancestors = ancestors.slice();\n\n  const { node: parent, key } = ancestors[ancestors.length - 1];\n\n  let type: PlaceholderType;\n  if (\n    isStringLiteral(node) ||\n    isPlaceholder(node, { expectedNode: \"StringLiteral\" })\n  ) {\n    type = \"string\";\n  } else if (\n    (isNewExpression(parent) && key === \"arguments\") ||\n    (isCallExpression(parent) && key === \"arguments\") ||\n    (isFunction(parent) && key === \"params\")\n  ) {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const { placeholders, placeholderNames } = state.isLegacyRef.value\n    ? state.legacy\n    : state.syntactic;\n\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name),\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {\n  let parent: t.Node = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const { key, index } = ancestors[i];\n\n    if (index === undefined) {\n      parent = (parent as any)[key];\n    } else {\n      parent = (parent as any)[key][index];\n    }\n  }\n\n  const { key, index } = ancestors[ancestors.length - 1];\n\n  return { parent, key, index };\n}\n\ntype MetadataState = {\n  syntactic: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  legacy: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  isLegacyRef: {\n    value?: boolean;\n  };\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  syntacticPlaceholders?: boolean;\n};\n\nfunction parseWithCodeFrame(\n  code: string,\n  parserOpts: ParserOpts,\n  syntacticPlaceholders?: boolean,\n): t.File {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = {\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\",\n    ...parserOpts,\n    plugins,\n  };\n\n  try {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    return parse(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + codeFrameColumns(code, { start: loc });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}