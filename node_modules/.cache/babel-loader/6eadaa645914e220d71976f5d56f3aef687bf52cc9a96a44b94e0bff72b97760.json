{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"buildDynamicImport\", {\n  enumerable: true,\n  get: function () {\n    return _dynamicImport.buildDynamicImport;\n  }\n});\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nObject.defineProperty(exports, \"getDynamicImportSource\", {\n  enumerable: true,\n  get: function () {\n    return _dynamicImport.getDynamicImportSource;\n  }\n});\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nexports.wrapInterop = wrapInterop;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nvar _template = require(\"@babel/template\");\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\nvar _rewriteThis = require(\"./rewrite-this\");\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\nvar _dynamicImport = require(\"./dynamic-import\");\nvar _getModuleName = require(\"./get-module-name\");\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nfunction rewriteModuleStatementsAndPrepareHeader(path, _ref) {\n  let {\n    loose,\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    lazy,\n    esNamespaceOnly,\n    filename,\n    constantReexports = loose,\n    enumerableModuleMeta = loose,\n    noIncompleteNsImportDetection\n  } = _ref;\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly,\n    filename\n  });\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n  (0, _rewriteLiveReferences.default)(path, meta);\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\n    }\n  }\n  const headers = [];\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n  const nameList = buildExportNameListDeclaration(path, meta);\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\n  return {\n    meta,\n    headers\n  };\n}\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n  let helper;\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\nfunction buildNamespaceInitStatements(metadata, sourceMetadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const statements = [];\n  let srcNamespace = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: cloneNode(srcNamespace)\n    }));\n  }\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: cloneNode(srcNamespace)\n    }));\n  }\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n  return statements;\n}\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: _template.default.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\nfunction buildReexportsFromMeta(meta, metadata, constantReexports) {\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, _ref2 => {\n    let [exportName, importName] = _ref2;\n    let NAMESPACE_IMPORT = cloneNode(namespace);\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\n    }\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n}\nfunction buildESModuleHeader(metadata) {\n  let enumerableModuleMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n  let hasReexport = false;\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\n  };\n}\nfunction buildExportInitializationStatements(programPath, metadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let noIncompleteNsImportDetection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const initStatements = [];\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n  initStatements.sort((_ref3, _ref4) => {\n    let [a] = _ref3;\n    let [b] = _ref4;\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n  const results = [];\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    const chunkSize = 100;\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n            uninitializedExportNames = [];\n          }\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n      if (uninitializedExportNames.length > 0) {\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n      }\n    }\n  }\n  return results;\n}\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}","map":{"version":3,"names":["_assert","require","_t","_template","_helperModuleImports","_rewriteThis","_rewriteLiveReferences","_normalizeAndLoadMetadata","_dynamicImport","_getModuleName","booleanLiteral","callExpression","cloneNode","directive","directiveLiteral","expressionStatement","identifier","isIdentifier","memberExpression","stringLiteral","valueToNode","variableDeclaration","variableDeclarator","rewriteModuleStatementsAndPrepareHeader","path","_ref","loose","exportName","strict","allowTopLevelThis","strictMode","noInterop","importInterop","lazy","esNamespaceOnly","filename","constantReexports","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","isModule","node","sourceType","meta","default","initializeReexports","hasStrict","directives","some","value","unshiftContainer","headers","hasExports","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","ensureStatementsHoisted","statements","forEach","header","_blockHoist","wrapInterop","programPath","expr","type","hub","addHelper","helper","Error","buildNamespaceInitStatements","metadata","sourceMetadata","arguments","length","undefined","srcNamespace","localName","importsNamespace","NAME","SOURCE","buildReexportsFromMeta","reexportNamespace","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","constantComputed","spec","namespace","stringSpecifiers","Array","from","reexports","_ref2","importName","NAMESPACE_IMPORT","interop","has","astNodes","EXPORT_NAME","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","Object","create","data","local","values","names","hasReexport","source","keys","scope","generateUidIdentifier","initStatements","kind","buildInitStatement","reexportsStatements","i","sort","_ref3","_ref4","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","buildUndefinedNode","InitTemplate","computed","expression","exportNames","initExpr","reduce","acc","params","VALUE"],"sources":["/home/nathan/Documents/project/node_modules/@babel/helper-module-transforms/src/index.ts"],"sourcesContent":["import assert from \"assert\";\nimport {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport template from \"@babel/template\";\n\nimport { isModule } from \"@babel/helper-module-imports\";\n\nimport rewriteThis from \"./rewrite-this\";\nimport rewriteLiveReferences from \"./rewrite-live-references\";\nimport normalizeModuleAndLoadMetadata, {\n  hasExports,\n  isSideEffectImport,\n  validateImportInteropOption,\n} from \"./normalize-and-load-metadata\";\nimport type {\n  ImportInterop,\n  InteropType,\n  Lazy,\n  ModuleMetadata,\n  SourceModuleMetadata,\n} from \"./normalize-and-load-metadata\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport { buildDynamicImport, getDynamicImportSource } from \"./dynamic-import\";\n\nexport { default as getModuleName } from \"./get-module-name\";\nexport type { PluginOptions } from \"./get-module-name\";\n\nexport { hasExports, isSideEffectImport, isModule, rewriteThis };\n\nexport interface RewriteModuleStatementsAndPrepareHeaderOptions {\n  exportName?: string;\n  strict: boolean;\n  allowTopLevelThis?: boolean;\n  strictMode: boolean;\n  loose?: boolean;\n  importInterop?: ImportInterop;\n  noInterop?: boolean;\n  lazy?: Lazy;\n  esNamespaceOnly?: boolean;\n  filename: string | undefined;\n  constantReexports?: boolean | void;\n  enumerableModuleMeta?: boolean | void;\n  noIncompleteNsImportDetection?: boolean | void;\n}\n\n/**\n * Perform all of the generic ES6 module rewriting needed to handle initial\n * module processing. This function will rewrite the majority of the given\n * program to reference the modules described by the returned metadata,\n * and returns a list of statements for use when initializing the module.\n */\nexport function rewriteModuleStatementsAndPrepareHeader(\n  path: NodePath<t.Program>,\n  {\n    // TODO(Babel 8): Remove this\n    loose,\n\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    lazy,\n    esNamespaceOnly,\n    filename,\n\n    constantReexports = loose,\n    enumerableModuleMeta = loose,\n    noIncompleteNsImportDetection,\n  }: RewriteModuleStatementsAndPrepareHeaderOptions,\n) {\n  validateImportInteropOption(importInterop);\n  assert(isModule(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n\n  const meta = normalizeModuleAndLoadMetadata(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly,\n    filename,\n  });\n\n  if (!allowTopLevelThis) {\n    rewriteThis(path);\n  }\n\n  rewriteLiveReferences(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n    if (!hasStrict) {\n      path.unshiftContainer(\n        \"directives\",\n        directive(directiveLiteral(\"use strict\")),\n      );\n    }\n  }\n\n  const headers = [];\n  if (hasExports(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  // Create all of the statically known named exports.\n  headers.push(\n    ...buildExportInitializationStatements(\n      path,\n      meta,\n      constantReexports,\n      noIncompleteNsImportDetection,\n    ),\n  );\n\n  return { meta, headers };\n}\n\n/**\n * Flag a set of statements as hoisted above all else so that module init\n * statements all run before user code.\n */\nexport function ensureStatementsHoisted(statements: t.Statement[]) {\n  // Force all of the header fields to be at the top of the file.\n  statements.forEach(header => {\n    // @ts-expect-error Fixme: handle _blockHoist property\n    header._blockHoist = 3;\n  });\n}\n\n/**\n * Given an expression for a standard import object, like \"require('foo')\",\n * wrap it in a call to the interop helpers based on the type.\n */\nexport function wrapInterop(\n  programPath: NodePath,\n  expr: t.Expression,\n  type: InteropType,\n): t.CallExpression {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [\n      expr,\n      booleanLiteral(true),\n    ]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\n/**\n * Create the runtime initialization statements for a given requested source.\n * These will initialize all of the runtime import/export logic that\n * can't be handled statically by the statements created by\n * buildExportInitializationStatements().\n */\nexport function buildNamespaceInitStatements(\n  metadata: ModuleMetadata,\n  sourceMetadata: SourceModuleMetadata,\n  constantReexports: boolean | void = false,\n) {\n  const statements = [];\n\n  let srcNamespace: t.Node = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n\n    // Create and assign binding to namespace object\n    statements.push(\n      template.statement`var NAME = SOURCE;`({\n        NAME: localName,\n        SOURCE: cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    // Assign export to namespace object.\n    statements.push(\n      (sourceMetadata.lazy\n        ? template.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          `\n        : template.statement`EXPORTS.NAME = NAMESPACE;`)({\n        EXPORTS: metadata.exportName,\n        NAME: exportName,\n        NAMESPACE: cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(\n      metadata,\n      cloneNode(srcNamespace),\n      constantReexports,\n    );\n    statement.loc = sourceMetadata.reexportAll.loc;\n\n    // Iterate props creating getter for each prop.\n    statements.push(statement);\n  }\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: template.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: template.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `,\n};\n\nfunction buildReexportsFromMeta(\n  meta: ModuleMetadata,\n  metadata: SourceModuleMetadata,\n  constantReexports: boolean,\n) {\n  const namespace = metadata.lazy\n    ? callExpression(identifier(metadata.name), [])\n    : identifier(metadata.name);\n\n  const { stringSpecifiers } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT: t.Expression = cloneNode(namespace);\n    if (importName === \"default\" && metadata.interop === \"node-default\") {\n      // Nothing, it's ok as-is\n    } else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        stringLiteral(importName),\n        true,\n      );\n    } else {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        identifier(importName),\n      );\n    }\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT,\n    };\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n}\n\n/**\n * Build an \"__esModule\" header statement setting the property on a given object.\n */\nfunction buildESModuleHeader(\n  metadata: ModuleMetadata,\n  enumerableModuleMeta: boolean | void = false,\n) {\n  return (\n    enumerableModuleMeta\n      ? template.statement`\n        EXPORTS.__esModule = true;\n      `\n      : template.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `\n  )({ EXPORTS: metadata.exportName });\n}\n\n/**\n * Create a re-export initialization loop for a specific imported namespace.\n */\nfunction buildNamespaceReexport(\n  metadata: ModuleMetadata,\n  namespace: t.Identifier | t.CallExpression,\n  constantReexports: boolean | void,\n) {\n  return (\n    constantReexports\n      ? template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      `\n      : // Also skip already assigned bindings if they are strictly equal\n        // to be somewhat more spec-compliant when a file has multiple\n        // namespace re-exports that would cause a binding to be exported\n        // multiple times. However, multiple bindings of the same name that\n        // export the same primitive value are silently skipped\n        // (the spec requires an \"ambiguous bindings\" early error here).\n        template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `\n  )({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName\n      ? template`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({ EXPORTS_LIST: metadata.exportNameListName })\n      : null,\n  });\n}\n\n/**\n * Build a statement declaring a variable that contains all of the exported\n * variable names in an object so they can easily be referenced from an\n * export * from statement to check for conflicts.\n */\nfunction buildExportNameListDeclaration(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n) {\n  const exportedVars = Object.create(null);\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n\n  delete exportedVars.default;\n\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [\n      variableDeclarator(name, valueToNode(exportedVars)),\n    ]),\n  };\n}\n\n/**\n * Create a set of statements that will initialize all of the statically-known\n * export names with their expected values.\n */\nfunction buildExportInitializationStatements(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n  constantReexports: boolean | void = false,\n  noIncompleteNsImportDetection: boolean | void = false,\n) {\n  const initStatements: Array<[string, t.Statement | null]> = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {\n      // No-open since these are explicitly set with the \"reexports\" block.\n    } else if (data.kind === \"hoisted\") {\n      initStatements.push([\n        // data.names is always of length 1 because a hoisted export\n        // name must be id of a function declaration\n        data.names[0],\n        buildInitStatement(metadata, data.names, identifier(localName)),\n      ]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n  // The [Exports] list is ordered as if an Array of those String values\n  // had been sorted using %Array.prototype.sort% using undefined as comparefn\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n\n  const results = [];\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    // We generate init statements (`exports.a = exports.b = ... = void 0`)\n    // for every 100 exported names to avoid deeply-nested AST structures.\n    const chunkSize = 100;\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(\n              buildInitStatement(\n                metadata,\n                uninitializedExportNames,\n                programPath.scope.buildUndefinedNode(),\n              ),\n            );\n            // reset after uninitializedExportNames has been transformed\n            // to init statements\n            uninitializedExportNames = [];\n          }\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n      if (uninitializedExportNames.length > 0) {\n        results.push(\n          buildInitStatement(\n            metadata,\n            uninitializedExportNames,\n            programPath.scope.buildUndefinedNode(),\n          ),\n        );\n      }\n    }\n  }\n\n  return results;\n}\n\n/**\n * Given a set of export names, create a set of nested assignments to\n * initialize them all to a given expression.\n */\nconst InitTemplate = {\n  computed: template.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: template.expression`EXPORTS.NAME = VALUE`,\n};\n\nfunction buildInitStatement(\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  initExpr: t.Expression,\n) {\n  const { stringSpecifiers, exportName: EXPORTS } = metadata;\n  return expressionStatement(\n    exportNames.reduce((acc, exportName) => {\n      const params = {\n        EXPORTS,\n        NAME: exportName,\n        VALUE: acc,\n      };\n      if (stringSpecifiers.has(exportName)) {\n        return InitTemplate.computed(params);\n      } else {\n        return InitTemplate.default(params);\n      }\n    }, initExpr),\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}