{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = literalTemplate;\nvar _options = require(\"./options\");\nvar _parse = require(\"./parse\");\nvar _populate = require(\"./populate\");\nfunction literalTemplate(formatter, tpl, opts) {\n  const {\n    metadata,\n    names\n  } = buildLiteralData(formatter, tpl, opts);\n  return arg => {\n    const defaultReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n    return arg => {\n      const replacements = (0, _options.normalizeReplacements)(arg);\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));\n    };\n  };\n}\nfunction buildLiteralData(formatter, tpl, opts) {\n  let names;\n  let nameSet;\n  let metadata;\n  let prefix = \"\";\n  do {\n    prefix += \"$\";\n    const result = buildTemplateCode(tpl, prefix);\n    names = result.names;\n    nameSet = new Set(names);\n    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {\n      parser: opts.parser,\n      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),\n      placeholderPattern: opts.placeholderPattern,\n      preserveComments: opts.preserveComments,\n      syntacticPlaceholders: opts.syntacticPlaceholders\n    });\n  } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));\n  return {\n    metadata,\n    names\n  };\n}\nfunction buildTemplateCode(tpl, prefix) {\n  const names = [];\n  let code = tpl[0];\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n    code += value + tpl[i];\n  }\n  return {\n    names,\n    code\n  };\n}","map":{"version":3,"names":["_options","require","_parse","_populate","literalTemplate","formatter","tpl","opts","metadata","names","buildLiteralData","arg","defaultReplacements","forEach","replacement","i","replacements","normalizeReplacements","Object","keys","key","prototype","hasOwnProperty","call","Error","unwrap","default","assign","nameSet","prefix","result","buildTemplateCode","Set","code","parser","placeholderWhitelist","concat","Array","from","placeholderPattern","preserveComments","syntacticPlaceholders","placeholders","some","placeholder","isDuplicate","has","name","length","value","push"],"sources":["/home/nathan/Documents/project/node_modules/@babel/template/src/literal.ts"],"sourcesContent":["import type { Formatter } from \"./formatters\";\nimport type { TemplateReplacements, TemplateOpts } from \"./options\";\nimport { normalizeReplacements } from \"./options\";\nimport parseAndBuildMetadata from \"./parse\";\nimport populatePlaceholders from \"./populate\";\n\nexport default function literalTemplate<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n): (_: Array<unknown>) => (_: unknown) => T {\n  const { metadata, names } = buildLiteralData(formatter, tpl, opts);\n\n  return arg => {\n    const defaultReplacements: TemplateReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n\n    return (arg: unknown) => {\n      const replacements = normalizeReplacements(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap(\n        populatePlaceholders(\n          metadata,\n          replacements\n            ? Object.assign(replacements, defaultReplacements)\n            : defaultReplacements,\n        ),\n      );\n    };\n  };\n}\n\nfunction buildLiteralData<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n) {\n  let names;\n  let nameSet: Set<string>;\n  let metadata;\n  let prefix = \"\";\n\n  do {\n    // If there are cases where the template already contains $0 or any other\n    // matching pattern, we keep adding \"$\" characters until a unique prefix\n    // is found.\n    prefix += \"$\";\n    const result = buildTemplateCode(tpl, prefix);\n\n    names = result.names;\n    nameSet = new Set(names);\n    metadata = parseAndBuildMetadata(formatter, formatter.code(result.code), {\n      parser: opts.parser,\n\n      // Explicitly include our generated names in the whitelist so users never\n      // have to think about whether their placeholder pattern will match.\n      placeholderWhitelist: new Set(\n        result.names.concat(\n          opts.placeholderWhitelist\n            ? Array.from(opts.placeholderWhitelist)\n            : [],\n        ),\n      ),\n      placeholderPattern: opts.placeholderPattern,\n      preserveComments: opts.preserveComments,\n      syntacticPlaceholders: opts.syntacticPlaceholders,\n    });\n  } while (\n    metadata.placeholders.some(\n      placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name),\n    )\n  );\n\n  return { metadata, names };\n}\n\nfunction buildTemplateCode(\n  tpl: Array<string>,\n  prefix: string,\n): { names: Array<string>; code: string } {\n  const names = [];\n\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n\n    code += value + tpl[i];\n  }\n\n  return { names, code };\n}\n"],"mappings":";;;;;;AAEA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AACA,IAAAE,SAAA,GAAAF,OAAA;AAEe,SAASG,eAAeA,CACrCC,SAAuB,EACvBC,GAAkB,EAClBC,IAAkB,EACwB;EAC1C,MAAM;IAAEC,QAAQ;IAAEC;EAAM,CAAC,GAAGC,gBAAgB,CAACL,SAAS,EAAEC,GAAG,EAAEC,IAAI,CAAC;EAElE,OAAOI,GAAG,IAAI;IACZ,MAAMC,mBAAyC,GAAG,CAAC,CAAC;IACpDD,GAAG,CAACE,OAAO,CAAC,CAACC,WAAW,EAAEC,CAAC,KAAK;MAC9BH,mBAAmB,CAACH,KAAK,CAACM,CAAC,CAAC,CAAC,GAAGD,WAAW;IAC7C,CAAC,CAAC;IAEF,OAAQH,GAAY,IAAK;MACvB,MAAMK,YAAY,GAAG,IAAAhB,QAAA,CAAAiB,qBAAqB,EAACN,GAAG,CAAC;MAE/C,IAAIK,YAAY,EAAE;QAChBE,MAAM,CAACC,IAAI,CAACH,YAAY,CAAC,CAACH,OAAO,CAACO,GAAG,IAAI;UACvC,IAAIF,MAAM,CAACG,SAAS,CAACC,cAAc,CAACC,IAAI,CAACX,mBAAmB,EAAEQ,GAAG,CAAC,EAAE;YAClE,MAAM,IAAII,KAAK,CAAC,iCAAiC,CAAC;UACpD;QACF,CAAC,CAAC;MACJ;MAEA,OAAOnB,SAAS,CAACoB,MAAM,CACrB,IAAAtB,SAAA,CAAAuB,OAAoB,EAClBlB,QAAQ,EACRQ,YAAY,GACRE,MAAM,CAACS,MAAM,CAACX,YAAY,EAAEJ,mBAAmB,CAAC,GAChDA,mBAAmB,CACxB,CACF;IACH,CAAC;EACH,CAAC;AACH;AAEA,SAASF,gBAAgBA,CACvBL,SAAuB,EACvBC,GAAkB,EAClBC,IAAkB,EAClB;EACA,IAAIE,KAAK;EACT,IAAImB,OAAoB;EACxB,IAAIpB,QAAQ;EACZ,IAAIqB,MAAM,GAAG,EAAE;EAEf,GAAG;IAIDA,MAAM,IAAI,GAAG;IACb,MAAMC,MAAM,GAAGC,iBAAiB,CAACzB,GAAG,EAAEuB,MAAM,CAAC;IAE7CpB,KAAK,GAAGqB,MAAM,CAACrB,KAAK;IACpBmB,OAAO,GAAG,IAAII,GAAG,CAACvB,KAAK,CAAC;IACxBD,QAAQ,GAAG,IAAAN,MAAA,CAAAwB,OAAqB,EAACrB,SAAS,EAAEA,SAAS,CAAC4B,IAAI,CAACH,MAAM,CAACG,IAAI,CAAC,EAAE;MACvEC,MAAM,EAAE3B,IAAI,CAAC2B,MAAM;MAInBC,oBAAoB,EAAE,IAAIH,GAAG,CAC3BF,MAAM,CAACrB,KAAK,CAAC2B,MAAM,CACjB7B,IAAI,CAAC4B,oBAAoB,GACrBE,KAAK,CAACC,IAAI,CAAC/B,IAAI,CAAC4B,oBAAoB,CAAC,GACrC,EAAE,CACP,CACF;MACDI,kBAAkB,EAAEhC,IAAI,CAACgC,kBAAkB;MAC3CC,gBAAgB,EAAEjC,IAAI,CAACiC,gBAAgB;MACvCC,qBAAqB,EAAElC,IAAI,CAACkC;IAC9B,CAAC,CAAC;EACJ,CAAC,QACCjC,QAAQ,CAACkC,YAAY,CAACC,IAAI,CACxBC,WAAW,IAAIA,WAAW,CAACC,WAAW,IAAIjB,OAAO,CAACkB,GAAG,CAACF,WAAW,CAACG,IAAI,CAAC,CACxE;EAGH,OAAO;IAAEvC,QAAQ;IAAEC;EAAM,CAAC;AAC5B;AAEA,SAASsB,iBAAiBA,CACxBzB,GAAkB,EAClBuB,MAAc,EAC0B;EACxC,MAAMpB,KAAK,GAAG,EAAE;EAEhB,IAAIwB,IAAI,GAAG3B,GAAG,CAAC,CAAC,CAAC;EAEjB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,GAAG,CAAC0C,MAAM,EAAEjC,CAAC,EAAE,EAAE;IACnC,MAAMkC,KAAK,GAAI,GAAEpB,MAAO,GAAEd,CAAC,GAAG,CAAE,EAAC;IACjCN,KAAK,CAACyC,IAAI,CAACD,KAAK,CAAC;IAEjBhB,IAAI,IAAIgB,KAAK,GAAG3C,GAAG,CAACS,CAAC,CAAC;EACxB;EAEA,OAAO;IAAEN,KAAK;IAAEwB;EAAK,CAAC;AACxB"},"metadata":{},"sourceType":"script","externalDependencies":[]}