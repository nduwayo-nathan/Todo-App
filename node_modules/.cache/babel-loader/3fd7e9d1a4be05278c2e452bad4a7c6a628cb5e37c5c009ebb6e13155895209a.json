{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildPresetChainWalker = void 0;\nexports.buildRootChain = buildRootChain;\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _debug() {\n  const data = require(\"debug\");\n  _debug = function () {\n    return data;\n  };\n  return data;\n}\nvar _options = require(\"./validation/options\");\nvar _patternToRegex = require(\"./pattern-to-regex\");\nvar _printer = require(\"./printer\");\nvar _rewriteStackTrace = require(\"../errors/rewrite-stack-trace\");\nvar _configError = require(\"../errors/config-error\");\nvar _files = require(\"./files\");\nvar _caching = require(\"./caching\");\nvar _configDescriptors = require(\"./config-descriptors\");\nconst debug = _debug()(\"babel:config:config-chain\");\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set()\n  };\n}\nconst buildPresetChainWalker = makeChainWalker({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\nfunction* buildRootChain(opts, context) {\n  let configReport, babelRcReport;\n  const programmaticLogger = new _printer.ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context, undefined, programmaticLogger);\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n  let configFile;\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n  const configFileLogger = new _printer.ConfigPrinter();\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n    mergeChain(configFileChain, result);\n  }\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n  if ((babelrc === true || babelrc === undefined) && typeof context.filename === \"string\") {\n    const pkgData = yield* (0, _files.findPackageData)(context.filename);\n    if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n      ({\n        ignore: ignoreFile,\n        config: babelrcFile\n      } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n      if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n        isIgnored = true;\n      }\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new _printer.ConfigPrinter();\n        const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n  if (context.showConfig) {\n    console.log(`Babel configs on \"${context.filename}\" (ascending priority):\\n` + [configReport, babelRcReport, programmaticReport].filter(x => !!x).join(\"\\n\\n\") + \"\\n-----End Babel configs-----\");\n  }\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files\n  };\n}\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n  let babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns];\n  }\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().resolve(babelrcRootsDirectory, pat) : pat;\n  });\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options, file.filepath)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options, file.filepath)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options, file.filepath)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName),\n  createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)\n});\nconst loadFileChainWalker = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)\n});\nfunction* loadFileChain(input, context, files, baseLogger) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n  if (chain) {\n    chain.files.add(input.filepath);\n  }\n  return chain;\n}\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\nfunction buildFileLogger(filepath, context, baseLogger) {\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {\n    filepath\n  });\n}\nfunction buildRootDescriptors(_ref, alias, descriptors) {\n  let {\n    dirname,\n    options\n  } = _ref;\n  return descriptors(dirname, options, alias);\n}\nfunction buildProgrammaticLogger(_, context, baseLogger) {\n  var _context$caller;\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {\n    callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name\n  });\n}\nfunction buildEnvDescriptors(_ref2, alias, descriptors, envName) {\n  let {\n    dirname,\n    options\n  } = _ref2;\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\nfunction buildOverrideDescriptors(_ref3, alias, descriptors, index) {\n  let {\n    dirname,\n    options\n  } = _ref3;\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\nfunction buildOverrideEnvDescriptors(_ref4, alias, descriptors, index, envName) {\n  let {\n    dirname,\n    options\n  } = _ref4;\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\nfunction makeChainWalker(_ref5) {\n  let {\n    root,\n    env,\n    overrides,\n    overridesEnv,\n    createLogger\n  } = _ref5;\n  return function chainWalker(input, context) {\n    let files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    let baseLogger = arguments.length > 3 ? arguments[3] : undefined;\n    return function* () {\n      const {\n        dirname\n      } = input;\n      const flattenedConfigs = [];\n      const rootOpts = root(input);\n      if (configIsApplicable(rootOpts, dirname, context, input.filepath)) {\n        flattenedConfigs.push({\n          config: rootOpts,\n          envName: undefined,\n          index: undefined\n        });\n        const envOpts = env(input, context.envName);\n        if (envOpts && configIsApplicable(envOpts, dirname, context, input.filepath)) {\n          flattenedConfigs.push({\n            config: envOpts,\n            envName: context.envName,\n            index: undefined\n          });\n        }\n        (rootOpts.options.overrides || []).forEach((_, index) => {\n          const overrideOps = overrides(input, index);\n          if (configIsApplicable(overrideOps, dirname, context, input.filepath)) {\n            flattenedConfigs.push({\n              config: overrideOps,\n              index,\n              envName: undefined\n            });\n            const overrideEnvOpts = overridesEnv(input, index, context.envName);\n            if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context, input.filepath)) {\n              flattenedConfigs.push({\n                config: overrideEnvOpts,\n                index,\n                envName: context.envName\n              });\n            }\n          }\n        });\n      }\n      if (flattenedConfigs.some(_ref6 => {\n        let {\n          config: {\n            options: {\n              ignore,\n              only\n            }\n          }\n        } = _ref6;\n        return shouldIgnore(context, ignore, only, dirname);\n      })) {\n        return null;\n      }\n      const chain = emptyChain();\n      const logger = createLogger(input, context, baseLogger);\n      for (const {\n        config,\n        index,\n        envName\n      } of flattenedConfigs) {\n        if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) {\n          return null;\n        }\n        logger(config, index, envName);\n        yield* mergeChainOpts(chain, config);\n      }\n      return chain;\n    }();\n  };\n}\nfunction* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n  return target;\n}\nfunction mergeChainOpts(target, _ref7) {\n  let {\n    options,\n    plugins,\n    presets\n  } = _ref7;\n  return function* () {\n    target.options.push(options);\n    target.plugins.push(...(yield* plugins()));\n    target.presets.push(...(yield* presets()));\n    return target;\n  }();\n}\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set()\n  };\n}\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n  return options;\n}\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n      let desc = nameMap.get(item.name);\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\nfunction configIsApplicable(_ref8, dirname, context, configName) {\n  let {\n    options\n  } = _ref8;\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname, configName)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname, configName)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname, configName));\n}\nfunction configFieldIsApplicable(context, test, dirname, configName) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname, configName);\n}\nfunction ignoreListReplacer(_key, value) {\n  if (value instanceof RegExp) {\n    return String(value);\n  }\n  return value;\n}\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    var _context$filename;\n    const message = `No config is applied to \"${(_context$filename = context.filename) != null ? _context$filename : \"(unknown)\"}\" because it matches one of \\`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n  if (only && !matchesPatterns(context, only, dirname)) {\n    var _context$filename2;\n    const message = `No config is applied to \"${(_context$filename2 = context.filename) != null ? _context$filename2 : \"(unknown)\"}\" because it fails to match one of \\`only: ${JSON.stringify(only, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n  return false;\n}\nfunction matchesPatterns(context, patterns, dirname, configName) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context, configName));\n}\nfunction matchPattern(pattern, dirname, pathToTest, context, configName) {\n  if (typeof pattern === \"function\") {\n    return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n  if (typeof pathToTest !== \"string\") {\n    throw new _configError.default(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`, configName);\n  }\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n  return pattern.test(pathToTest);\n}\n0 && 0;","map":{"version":3,"names":["_path","data","require","_debug","_options","_patternToRegex","_printer","_rewriteStackTrace","_configError","_files","_caching","_configDescriptors","debug","buildPresetChain","arg","context","chain","buildPresetChainWalker","plugins","dedupDescriptors","presets","options","map","o","normalizeOptions","files","Set","makeChainWalker","root","preset","loadPresetDescriptors","env","envName","loadPresetEnvDescriptors","overrides","index","loadPresetOverridesDescriptors","overridesEnv","loadPresetOverridesEnvDescriptors","createLogger","exports","makeWeakCacheSync","buildRootDescriptors","alias","createUncachedDescriptors","makeStrongCacheSync","buildEnvDescriptors","buildOverrideDescriptors","buildOverrideEnvDescriptors","buildRootChain","opts","configReport","babelRcReport","programmaticLogger","ConfigPrinter","programmaticChain","loadProgrammaticChain","dirname","cwd","undefined","programmaticReport","output","configFile","loadConfig","caller","findRootConfig","babelrc","babelrcRoots","babelrcRootsDirectory","configFileChain","emptyChain","configFileLogger","validatedFile","validateConfigFile","result","loadFileChain","mergeChain","ignoreFile","babelrcFile","isIgnored","fileChain","filename","pkgData","findPackageData","babelrcLoadEnabled","ignore","config","findRelativeConfig","add","filepath","shouldIgnore","validateBabelrcFile","babelrcLogger","showConfig","console","log","filter","x","join","fileHandling","absoluteRoot","directories","indexOf","babelrcPatterns","Array","isArray","pat","resolve","length","some","default","directory","matchPattern","file","validate","validateExtendFile","input","createCachedDescriptors","baseLogger","buildProgrammaticLogger","loadFileChainWalker","loadFileDescriptors","loadFileEnvDescriptors","loadFileOverridesDescriptors","loadFileOverridesEnvDescriptors","buildFileLogger","configure","ChainFormatter","Config","_ref","descriptors","_","_context$caller","Programmatic","callerName","name","_ref2","_ref3","Error","_ref4","override","_ref5","chainWalker","arguments","flattenedConfigs","rootOpts","configIsApplicable","push","envOpts","forEach","overrideOps","overrideEnvOpts","_ref6","only","logger","mergeExtendsChain","mergeChainOpts","extends","has","from","delete","target","source","_ref7","Object","assign","passPerPreset","test","include","exclude","prototype","hasOwnProperty","call","sourceMaps","sourceMap","items","Map","item","value","fnKey","nameMap","get","set","desc","ownPass","reduce","acc","_ref8","configName","configFieldIsApplicable","patterns","matchesPatterns","ignoreListReplacer","_key","RegExp","String","_context$filename","message","JSON","stringify","_context$filename2","pattern","pathToTest","endHiddenCallStack"],"sources":["/home/nathan/Documents/project/node_modules/@babel/core/src/config/config-chain.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport path from \"path\";\nimport buildDebug from \"debug\";\nimport type { Handler } from \"gensync\";\nimport { validate } from \"./validation/options\";\nimport type {\n  ValidatedOptions,\n  IgnoreList,\n  ConfigApplicableTest,\n  BabelrcSearch,\n  CallerMetadata,\n  IgnoreItem,\n} from \"./validation/options\";\nimport pathPatternToRegex from \"./pattern-to-regex\";\nimport { ConfigPrinter, ChainFormatter } from \"./printer\";\nimport type { ReadonlyDeepArray } from \"./helpers/deep-array\";\n\nimport { endHiddenCallStack } from \"../errors/rewrite-stack-trace\";\nimport ConfigError from \"../errors/config-error\";\n\nconst debug = buildDebug(\"babel:config:config-chain\");\n\nimport {\n  findPackageData,\n  findRelativeConfig,\n  findRootConfig,\n  loadConfig,\n} from \"./files\";\nimport type { ConfigFile, IgnoreFile, FilePackageData } from \"./files\";\n\nimport { makeWeakCacheSync, makeStrongCacheSync } from \"./caching\";\n\nimport {\n  createCachedDescriptors,\n  createUncachedDescriptors,\n} from \"./config-descriptors\";\nimport type {\n  UnloadedDescriptor,\n  OptionsAndDescriptors,\n  ValidatedFile,\n} from \"./config-descriptors\";\n\nexport type ConfigChain = {\n  plugins: Array<UnloadedDescriptor>;\n  presets: Array<UnloadedDescriptor>;\n  options: Array<ValidatedOptions>;\n  files: Set<string>;\n};\n\nexport type PresetInstance = {\n  options: ValidatedOptions;\n  alias: string;\n  dirname: string;\n  externalDependencies: ReadonlyDeepArray<string>;\n};\n\nexport type ConfigContext = {\n  filename: string | undefined;\n  cwd: string;\n  root: string;\n  envName: string;\n  caller: CallerMetadata | undefined;\n  showConfig: boolean;\n};\n\n/**\n * Build a config chain for a given preset.\n */\nexport function* buildPresetChain(\n  arg: PresetInstance,\n  context: any,\n): Handler<ConfigChain | null> {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set(),\n  };\n}\n\nexport const buildPresetChainWalker = makeChainWalker<PresetInstance>({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) =>\n    loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}, // Currently we don't support logging how preset is expanded\n});\nconst loadPresetDescriptors = makeWeakCacheSync((preset: PresetInstance) =>\n  buildRootDescriptors(preset, preset.alias, createUncachedDescriptors),\n);\nconst loadPresetEnvDescriptors = makeWeakCacheSync((preset: PresetInstance) =>\n  makeStrongCacheSync((envName: string) =>\n    buildEnvDescriptors(\n      preset,\n      preset.alias,\n      createUncachedDescriptors,\n      envName,\n    ),\n  ),\n);\nconst loadPresetOverridesDescriptors = makeWeakCacheSync(\n  (preset: PresetInstance) =>\n    makeStrongCacheSync((index: number) =>\n      buildOverrideDescriptors(\n        preset,\n        preset.alias,\n        createUncachedDescriptors,\n        index,\n      ),\n    ),\n);\nconst loadPresetOverridesEnvDescriptors = makeWeakCacheSync(\n  (preset: PresetInstance) =>\n    makeStrongCacheSync((index: number) =>\n      makeStrongCacheSync((envName: string) =>\n        buildOverrideEnvDescriptors(\n          preset,\n          preset.alias,\n          createUncachedDescriptors,\n          index,\n          envName,\n        ),\n      ),\n    ),\n);\n\nexport type FileHandling = \"transpile\" | \"ignored\" | \"unsupported\";\nexport type RootConfigChain = ConfigChain & {\n  babelrc: ConfigFile | void;\n  config: ConfigFile | void;\n  ignore: IgnoreFile | void;\n  fileHandling: FileHandling;\n  files: Set<string>;\n};\n\n/**\n * Build a config chain for Babel's full root configuration.\n */\nexport function* buildRootChain(\n  opts: ValidatedOptions,\n  context: ConfigContext,\n): Handler<RootConfigChain | null> {\n  let configReport, babelRcReport;\n  const programmaticLogger = new ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain(\n    {\n      options: opts,\n      dirname: context.cwd,\n    },\n    context,\n    undefined,\n    programmaticLogger,\n  );\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n\n  let configFile;\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* loadConfig(\n      opts.configFile,\n      context.cwd,\n      context.envName,\n      context.caller,\n    );\n  } else if (opts.configFile !== false) {\n    configFile = yield* findRootConfig(\n      context.root,\n      context.envName,\n      context.caller,\n    );\n  }\n\n  let { babelrc, babelrcRoots } = opts;\n  let babelrcRootsDirectory = context.cwd;\n\n  const configFileChain = emptyChain();\n  const configFileLogger = new ConfigPrinter();\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(\n      validatedFile,\n      context,\n      undefined,\n      configFileLogger,\n    );\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n\n    // Allow config files to toggle `.babelrc` resolution on and off and\n    // specify where the roots are.\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n  // resolve all .babelrc files\n  if (\n    (babelrc === true || babelrc === undefined) &&\n    typeof context.filename === \"string\"\n  ) {\n    const pkgData = yield* findPackageData(context.filename);\n\n    if (\n      pkgData &&\n      babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)\n    ) {\n      ({ ignore: ignoreFile, config: babelrcFile } = yield* findRelativeConfig(\n        pkgData,\n        context.envName,\n        context.caller,\n      ));\n\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n\n      if (\n        ignoreFile &&\n        shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)\n      ) {\n        isIgnored = true;\n      }\n\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new ConfigPrinter();\n        const result = yield* loadFileChain(\n          validatedFile,\n          context,\n          undefined,\n          babelrcLogger,\n        );\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n\n  if (context.showConfig) {\n    console.log(\n      `Babel configs on \"${context.filename}\" (ascending priority):\\n` +\n        // print config by the order of ascending priority\n        [configReport, babelRcReport, programmaticReport]\n          .filter(x => !!x)\n          .join(\"\\n\\n\") +\n        \"\\n-----End Babel configs-----\",\n    );\n  }\n  // Insert file chain in front so programmatic options have priority\n  // over configuration file chain items.\n  const chain = mergeChain(\n    mergeChain(mergeChain(emptyChain(), configFileChain), fileChain),\n    programmaticChain,\n  );\n\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files,\n  };\n}\n\nfunction babelrcLoadEnabled(\n  context: ConfigContext,\n  pkgData: FilePackageData,\n  babelrcRoots: BabelrcSearch | undefined,\n  babelrcRootsDirectory: string,\n): boolean {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n\n  const absoluteRoot = context.root;\n\n  // Fast path to avoid having to match patterns if the babelrc is just\n  // loading in the standard root directory.\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns as IgnoreItem];\n  }\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\"\n      ? path.resolve(babelrcRootsDirectory, pat)\n      : pat;\n  });\n\n  // Fast path to avoid having to match patterns if the babelrc is just\n  // loading in the standard root directory.\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = pathPatternToRegex(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = makeWeakCacheSync(\n  (file: ConfigFile): ValidatedFile => ({\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: validate(\"configfile\", file.options, file.filepath),\n  }),\n);\n\nconst validateBabelrcFile = makeWeakCacheSync(\n  (file: ConfigFile): ValidatedFile => ({\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: validate(\"babelrcfile\", file.options, file.filepath),\n  }),\n);\n\nconst validateExtendFile = makeWeakCacheSync(\n  (file: ConfigFile): ValidatedFile => ({\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: validate(\"extendsfile\", file.options, file.filepath),\n  }),\n);\n\n/**\n * Build a config chain for just the programmatic options passed into Babel.\n */\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", createCachedDescriptors),\n  env: (input, envName) =>\n    buildEnvDescriptors(input, \"base\", createCachedDescriptors, envName),\n  overrides: (input, index) =>\n    buildOverrideDescriptors(input, \"base\", createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) =>\n    buildOverrideEnvDescriptors(\n      input,\n      \"base\",\n      createCachedDescriptors,\n      index,\n      envName,\n    ),\n  createLogger: (input, context, baseLogger) =>\n    buildProgrammaticLogger(input, context, baseLogger),\n});\n\n/**\n * Build a config chain for a given file.\n */\nconst loadFileChainWalker = makeChainWalker<ValidatedFile>({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) =>\n    loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) =>\n    buildFileLogger(file.filepath, context, baseLogger),\n});\n\nfunction* loadFileChain(\n  input: ValidatedFile,\n  context: ConfigContext,\n  files: Set<ConfigFile>,\n  baseLogger: ConfigPrinter,\n) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n  if (chain) {\n    chain.files.add(input.filepath);\n  }\n\n  return chain;\n}\n\nconst loadFileDescriptors = makeWeakCacheSync((file: ValidatedFile) =>\n  buildRootDescriptors(file, file.filepath, createUncachedDescriptors),\n);\nconst loadFileEnvDescriptors = makeWeakCacheSync((file: ValidatedFile) =>\n  makeStrongCacheSync((envName: string) =>\n    buildEnvDescriptors(\n      file,\n      file.filepath,\n      createUncachedDescriptors,\n      envName,\n    ),\n  ),\n);\nconst loadFileOverridesDescriptors = makeWeakCacheSync((file: ValidatedFile) =>\n  makeStrongCacheSync((index: number) =>\n    buildOverrideDescriptors(\n      file,\n      file.filepath,\n      createUncachedDescriptors,\n      index,\n    ),\n  ),\n);\nconst loadFileOverridesEnvDescriptors = makeWeakCacheSync(\n  (file: ValidatedFile) =>\n    makeStrongCacheSync((index: number) =>\n      makeStrongCacheSync((envName: string) =>\n        buildOverrideEnvDescriptors(\n          file,\n          file.filepath,\n          createUncachedDescriptors,\n          index,\n          envName,\n        ),\n      ),\n    ),\n);\n\nfunction buildFileLogger(\n  filepath: string,\n  context: ConfigContext,\n  baseLogger: ConfigPrinter | void,\n) {\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, ChainFormatter.Config, {\n    filepath,\n  });\n}\n\nfunction buildRootDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n) {\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildProgrammaticLogger(\n  _: unknown,\n  context: ConfigContext,\n  baseLogger: ConfigPrinter | void,\n) {\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, ChainFormatter.Programmatic, {\n    callerName: context.caller?.name,\n  });\n}\n\nfunction buildEnvDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n  envName: string,\n) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n  index: number,\n) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n  index: number,\n  envName: string,\n) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n\n  const opts = override.env && override.env[envName];\n  return opts\n    ? descriptors(\n        dirname,\n        opts,\n        `${alias}.overrides[${index}].env[\"${envName}\"]`,\n      )\n    : null;\n}\n\nfunction makeChainWalker<\n  ArgT extends {\n    options: ValidatedOptions;\n    dirname: string;\n    filepath?: string;\n  },\n>({\n  root,\n  env,\n  overrides,\n  overridesEnv,\n  createLogger,\n}: {\n  root: (configEntry: ArgT) => OptionsAndDescriptors;\n  env: (configEntry: ArgT, env: string) => OptionsAndDescriptors | null;\n  overrides: (configEntry: ArgT, index: number) => OptionsAndDescriptors;\n  overridesEnv: (\n    configEntry: ArgT,\n    index: number,\n    env: string,\n  ) => OptionsAndDescriptors | null;\n  createLogger: (\n    configEntry: ArgT,\n    context: ConfigContext,\n    printer: ConfigPrinter | void,\n  ) => (\n    opts: OptionsAndDescriptors,\n    index?: number | null,\n    env?: string | null,\n  ) => void;\n}): (\n  configEntry: ArgT,\n  context: ConfigContext,\n  files?: Set<ConfigFile>,\n  baseLogger?: ConfigPrinter,\n) => Handler<ConfigChain | null> {\n  return function* chainWalker(input, context, files = new Set(), baseLogger) {\n    const { dirname } = input;\n\n    const flattenedConfigs: Array<{\n      config: OptionsAndDescriptors;\n      index: number | undefined | null;\n      envName: string | undefined | null;\n    }> = [];\n\n    const rootOpts = root(input);\n    if (configIsApplicable(rootOpts, dirname, context, input.filepath)) {\n      flattenedConfigs.push({\n        config: rootOpts,\n        envName: undefined,\n        index: undefined,\n      });\n\n      const envOpts = env(input, context.envName);\n      if (\n        envOpts &&\n        configIsApplicable(envOpts, dirname, context, input.filepath)\n      ) {\n        flattenedConfigs.push({\n          config: envOpts,\n          envName: context.envName,\n          index: undefined,\n        });\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n        if (configIsApplicable(overrideOps, dirname, context, input.filepath)) {\n          flattenedConfigs.push({\n            config: overrideOps,\n            index,\n            envName: undefined,\n          });\n\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n          if (\n            overrideEnvOpts &&\n            configIsApplicable(\n              overrideEnvOpts,\n              dirname,\n              context,\n              input.filepath,\n            )\n          ) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName,\n            });\n          }\n        }\n      });\n    }\n\n    // Process 'ignore' and 'only' before 'extends' items are processed so\n    // that we don't do extra work loading extended configs if a file is\n    // ignored.\n    if (\n      flattenedConfigs.some(\n        ({\n          config: {\n            options: { ignore, only },\n          },\n        }) => shouldIgnore(context, ignore, only, dirname),\n      )\n    ) {\n      return null;\n    }\n\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n\n    for (const { config, index, envName } of flattenedConfigs) {\n      if (\n        !(yield* mergeExtendsChain(\n          chain,\n          config.options,\n          dirname,\n          context,\n          files,\n          baseLogger,\n        ))\n      ) {\n        return null;\n      }\n\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(\n  chain: ConfigChain,\n  opts: ValidatedOptions,\n  dirname: string,\n  context: ConfigContext,\n  files: Set<ConfigFile>,\n  baseLogger?: ConfigPrinter,\n): Handler<boolean> {\n  if (opts.extends === undefined) return true;\n\n  const file = yield* loadConfig(\n    opts.extends,\n    dirname,\n    context.envName,\n    context.caller,\n  );\n\n  if (files.has(file)) {\n    throw new Error(\n      `Configuration cycle detected loading ${file.filepath}.\\n` +\n        `File already loaded following the config chain:\\n` +\n        Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"),\n    );\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(\n    validateExtendFile(file),\n    context,\n    files,\n    baseLogger,\n  );\n  files.delete(file);\n\n  if (!fileChain) return false;\n\n  mergeChain(chain, fileChain);\n\n  return true;\n}\n\nfunction mergeChain(target: ConfigChain, source: ConfigChain): ConfigChain {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n\n  return target;\n}\n\nfunction* mergeChainOpts(\n  target: ConfigChain,\n  { options, plugins, presets }: OptionsAndDescriptors,\n): Handler<ConfigChain> {\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n\n  return target;\n}\n\nfunction emptyChain(): ConfigChain {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set(),\n  };\n}\n\nfunction normalizeOptions(opts: ValidatedOptions): ValidatedOptions {\n  const options = {\n    ...opts,\n  };\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  // \"sourceMap\" is just aliased to sourceMap, so copy it over as\n  // we merge the options together.\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n  return options;\n}\n\nfunction dedupDescriptors(\n  items: Array<UnloadedDescriptor>,\n): Array<UnloadedDescriptor> {\n  const map: Map<\n    Function,\n    Map<string | void, { value: UnloadedDescriptor }>\n  > = new Map();\n\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n      let desc = nameMap.get(item.name);\n      if (!desc) {\n        desc = { value: item };\n        descriptors.push(desc);\n\n        // Treat passPerPreset presets as unique, skipping them\n        // in the merge processing steps.\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({ value: item });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable(\n  { options }: OptionsAndDescriptors,\n  dirname: string,\n  context: ConfigContext,\n  configName: string,\n): boolean {\n  return (\n    (options.test === undefined ||\n      configFieldIsApplicable(context, options.test, dirname, configName)) &&\n    (options.include === undefined ||\n      configFieldIsApplicable(context, options.include, dirname, configName)) &&\n    (options.exclude === undefined ||\n      !configFieldIsApplicable(context, options.exclude, dirname, configName))\n  );\n}\n\nfunction configFieldIsApplicable(\n  context: ConfigContext,\n  test: ConfigApplicableTest,\n  dirname: string,\n  configName: string,\n): boolean {\n  const patterns = Array.isArray(test) ? test : [test];\n\n  return matchesPatterns(context, patterns, dirname, configName);\n}\n\n/**\n * Print the ignoreList-values in a more helpful way than the default.\n */\nfunction ignoreListReplacer(\n  _key: string,\n  value: IgnoreList | IgnoreItem,\n): IgnoreList | IgnoreItem | string {\n  if (value instanceof RegExp) {\n    return String(value);\n  }\n\n  return value;\n}\n\n/**\n * Tests if a filename should be ignored based on \"ignore\" and \"only\" options.\n */\nfunction shouldIgnore(\n  context: ConfigContext,\n  ignore: IgnoreList | undefined | null,\n  only: IgnoreList | undefined | null,\n  dirname: string,\n): boolean {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    const message = `No config is applied to \"${\n      context.filename ?? \"(unknown)\"\n    }\" because it matches one of \\`ignore: ${JSON.stringify(\n      ignore,\n      ignoreListReplacer,\n    )}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    const message = `No config is applied to \"${\n      context.filename ?? \"(unknown)\"\n    }\" because it fails to match one of \\`only: ${JSON.stringify(\n      only,\n      ignoreListReplacer,\n    )}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns result of calling function with filename if pattern is a function.\n * Otherwise returns result of matching pattern Regex with filename.\n */\nfunction matchesPatterns(\n  context: ConfigContext,\n  patterns: IgnoreList,\n  dirname: string,\n  configName?: string,\n): boolean {\n  return patterns.some(pattern =>\n    matchPattern(pattern, dirname, context.filename, context, configName),\n  );\n}\n\nfunction matchPattern(\n  pattern: IgnoreItem,\n  dirname: string,\n  pathToTest: string | undefined,\n  context: ConfigContext,\n  configName?: string,\n): boolean {\n  if (typeof pattern === \"function\") {\n    return !!endHiddenCallStack(pattern)(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller,\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new ConfigError(\n      `Configuration contains string/RegExp pattern, but no filename was passed to Babel`,\n      configName,\n    );\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = pathPatternToRegex(pattern, dirname);\n  }\n  return pattern.test(pathToTest);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}